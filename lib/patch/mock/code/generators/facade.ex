defmodule Patch.Mock.Code.Generators.Facade do
  @moduledoc """
  Generator for `facade` modules.

  `facade` modules are generated by taking the `target` module and creating a stub function for
  each function in the module that calls the `delegate` modules corresponding function.

  The `facade` module can optionally expose private functions as public.
  """

  alias Patch.Mock.Naming
  alias Patch.Mock.Code.Query
  alias Patch.Mock.Code.Transform

  @generated [generated: true]

  @doc """
  Generates a new facade module based on the forms of the provided module.
  """
  @spec generate(abstract_forms :: [Code.form()], module :: module(), exposes :: Transform.exposes()) :: [Code.form()]
  def generate(abstract_forms, module, :none) do
    exports = Query.exports(abstract_forms)

    module(abstract_forms, module, exports)
  end

  def generate(abstract_forms, module, :all) do
    exports = Query.functions(abstract_forms)

    abstract_forms
    |> module(module, exports)
    |> Transform.expose(:all)
  end

  def generate(abstract_forms, module, exposes) do
    exports = exposes ++ Query.exports(abstract_forms)

    abstract_forms
    |> module(module, exports)
    |> Transform.expose(exposes)
  end

  ## Private

  defp arguments(0) do
    []
  end

  defp arguments(arity) do
    Enum.map(1..arity, &{:var, @generated, :"_arg#{&1}"})
  end


  defp body(module, name, arity) do
    delegate = Naming.delegate(module)

    [
      {
        :call,
        @generated,
        {:remote, @generated, {:atom, @generated, delegate}, {:atom, @generated, name}},
        arguments(arity)
      }
    ]
  end

  defp function(module, name, arity) do
    clause = {
      :clause,
      @generated,
      patterns(arity),
      [],
      body(module, name, arity)
    }

    {:function, @generated, name, arity, [clause]}
  end

  @spec module(abstract_forms :: [Code.form()], module :: module(), exports :: Code.exports()) :: [Code.form()]
  defp module(abstract_forms, module, exports) do
    Enum.map(abstract_forms, fn
      {:function, _, name, arity, _} = function ->
        if {name, arity} in exports do
          function(module, name, arity)
        else
          function
        end

      other ->
        other
    end)
  end

  defp patterns(0) do
    []
  end

  defp patterns(arity) do
    Enum.map(1..arity, fn position ->
      {:var, @generated, :"_arg#{position}"}
    end)
  end
end
